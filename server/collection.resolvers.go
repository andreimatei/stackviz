package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"stacksviz/ent"
	"stacksviz/ent/collection"
	"stacksviz/ent/framespec"
	"stacksviz/graph"
	"stacksviz/stacks"
	"time"

	pp "github.com/maruel/panicparse/v2/stack"
	"golang.org/x/sync/errgroup"
)

// CollectServiceSnapshots is the resolver for the collectServiceSnapshots field.
func (r *mutationResolver) CollectServiceSnapshots(ctx context.Context) (*ent.Collection, error) {
	dbClient := ent.FromContext(ctx)
	psIDs := make([]int, 0, len(r.conf.Targets))

	// Read the name of the first (and only) service.
	if len(r.conf.Targets) != 1 {
		return nil, fmt.Errorf("expected exactly one service")
	}

	spec := getOrCreateCollectSpec(ctx, dbClient)
	var g errgroup.Group
	for i, target := range r.getTargets() {
		target := target
		g.Go(func() error {
			log.Printf("collecting snapshot from process %d: %s - %s", i, target.processName, target.URL)
			snap, err := r.getSnapshotFromDelveAgent(ctx, target.URL, spec)
			if err != nil {
				return err
			}
			log.Printf("!!! delve agent returned")
			var framesOfInterest string
			if len(snap.FramesOfInterest) > 0 {
				b, err := json.Marshal(snap.FramesOfInterest)
				if err != nil {
					return err
				}
				framesOfInterest = string(b)
			}

			log.Printf("!!! creating snapshot with %d stacks\nframes of interest: %s\nflight recorder data: %v",
				len(snap.Stacks), framesOfInterest, snap.FlightRecorderData)
			input := ent.CreateProcessSnapshotInput{
				ProcessID:          target.processName,
				Snapshot:           stacksToString(snap),
				FlightRecorderData: snap.FlightRecorderData,
			}
			if framesOfInterest != "" {
				input.FramesOfInterest = &framesOfInterest
			}
			ps, err := dbClient.ProcessSnapshot.Create().SetInput(input).Save(ctx)
			if err != nil {
				return err
			}
			psIDs = append(psIDs, ps.ID)
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return nil, err
	}

	const timeFormat = "Monday, 02-Jan-06 15:04:05 MST"
	return dbClient.Collection.Create().
		SetName(fmt.Sprintf("%s - %s", r.getTargets()[0].serviceName, time.Now().Format(timeFormat))).
		SetCollectSpec(spec.ID).
		AddProcessSnapshotIDs(psIDs...).
		Save(ctx)
}

// AddExprToCollectSpec is the resolver for the addExprToCollectSpec mutation.
func (r *mutationResolver) AddExprToCollectSpec(ctx context.Context, frame string, expr string) (_ *ent.CollectSpec, _err error) {
	dbClient := ent.FromContext(ctx)
	log.Printf("!!! AddExprToCollectSpec: starting")
	defer func() {
		log.Printf("!!! AddExprToCollectSpec: done")
	}()

	collectSpec := getOrCreateCollectSpec(ctx, dbClient)
	// Create of update the frame info.
	fi, err := collectSpec.QueryFrames().Where(framespec.Frame(frame)).Only(ctx)
	nfe := &ent.NotFoundError{}
	if errors.As(err, &nfe) {
		// Create a new FrameSpec with the given expression.
		fi = dbClient.FrameSpec.Create().
			SetParentCollection(collectSpec).
			SetFrame(frame).
			SetCollectExpressions([]string{expr}).
			SetFlightRecorderEvents([]string{}).
			SaveX(ctx)
		// !!! collectSpec = collectSpec.Update().AddFrames(fi).SaveX(ctx)
		return collectSpec, nil
	}
	if err != nil {
		return nil, err
	}
	for _, e := range fi.CollectExpressions {
		if e == expr {
			return collectSpec, nil
		}
	}
	fi.Update().SetCollectExpressions(append(fi.CollectExpressions, expr)).SaveX(ctx)
	return collectSpec, nil
}

// RemoveExprFromCollectSpec is the resolver for the removeExprFromCollectSpec field.
func (r *mutationResolver) RemoveExprFromCollectSpec(ctx context.Context, expr string, frame string) (*ent.CollectSpec, error) {
	log.Printf("!!! RemoveExprFromCollectSpec resolver")
	dbClient := ent.FromContext(ctx)
	collectSpec := getOrCreateCollectSpec(ctx, dbClient)
	fi, err := collectSpec.QueryFrames().Where(framespec.Frame(frame)).Only(ctx)
	nfe := &ent.NotFoundError{}
	if errors.As(err, &nfe) {
		return collectSpec, nil
	}
	foundIndex := -1
	for i, e := range fi.CollectExpressions {
		if e == expr {
			foundIndex = i
			break
		}
	}
	if foundIndex != -1 {
		fi.Update().SetCollectExpressions(append(fi.CollectExpressions[:foundIndex], fi.CollectExpressions[foundIndex+1:]...)).SaveX(ctx)
	}
	return collectSpec, nil
}

// AddFlightRecorderEventToFrameSpec is the resolver for the addFlightRecorderEventToFrameSpec field.
func (r *mutationResolver) AddFlightRecorderEventToFrameSpec(ctx context.Context, collectSpecID int, frame string, expr string, keyExpr string) (*ent.FrameSpec, error) {
	log.Printf("!!! AddFlightRecorderEventToFrameSpec resolver: %s - %s (%s)", frame, expr, keyExpr)
	dbClient := ent.FromContext(ctx)
	ev := FlightRecorderEventSpecFull{
		Frame: frame,
		FlightRecorderEventSpec: FlightRecorderEventSpec{
			Expr:    expr,
			KeyExpr: keyExpr,
		},
	}
	data, err := json.Marshal(ev)
	if err != nil {
		return nil, err
	}

	// Create or update the frame info.
	frameSpec, err := dbClient.FrameSpec.Query().Where(
		framespec.CollectSpecID(collectSpecID), framespec.Frame(frame),
	).Only(ctx)
	nfe := &ent.NotFoundError{}
	if errors.As(err, &nfe) {
		frameSpec = dbClient.FrameSpec.Create().
			SetParentCollectionID(collectSpecID).
			SetFrame(frame).
			SetCollectExpressions([]string{}).
			SetFlightRecorderEvents([]string{string(data)}).
			SaveX(ctx)
		return frameSpec, nil
	}
	if err != nil {
		return nil, err
	}
	// Check if an identical spec already exists. If it does, there's nothing to do.
	for _, e := range frameSpec.FlightRecorderEvents {
		var ev FlightRecorderEventSpec
		json.Unmarshal([]byte(e), &ev)
		if ev.Expr == expr && ev.KeyExpr == keyExpr {
			return frameSpec, nil
		}
	}
	log.Printf("!!! adding flight recorder event: %s", string(data))
	frameSpec.Update().SetFlightRecorderEvents(append(frameSpec.FlightRecorderEvents, string(data))).SaveX(ctx)
	log.Printf("!!! events for %s are now: %s", frameSpec.Frame, frameSpec.FlightRecorderEvents)

	_, err = r.SyncFlightRecorder(ctx, collectSpecID)
	if err != nil {
		return nil, err
	}

	return frameSpec, nil
}

// RemoveFlightRecorderEventFromCollectSpec is the resolver for the removeFlightRecorderEventFromCollectSpec field.
func (r *mutationResolver) RemoveFlightRecorderEventFromCollectSpec(ctx context.Context, frame string, expr string, keyExpr string) (*ent.CollectSpec, error) {
	log.Printf("!!! RemoveFlightRecorderEventFromCollectSpec resolver")
	dbClient := ent.FromContext(ctx)
	collectSpec := getOrCreateCollectSpec(ctx, dbClient)
	fi, err := collectSpec.QueryFrames().Where(framespec.Frame(frame)).Only(ctx)
	nfe := &ent.NotFoundError{}
	if errors.As(err, &nfe) {
		return collectSpec, nil
	}
	foundIndex := -1
	for i, e := range fi.FlightRecorderEvents {
		var ev FlightRecorderEventSpec
		json.Unmarshal([]byte(e), &ev)
		if ev.Expr == expr && ev.KeyExpr == keyExpr {
			foundIndex = i
			break
		}
	}
	if foundIndex != -1 {
		fi.Update().SetFlightRecorderEvents(
			append(fi.CollectExpressions[:foundIndex], fi.CollectExpressions[foundIndex+1:]...),
		).SaveX(ctx)
	}
	return collectSpec, nil
}

// SyncFlightRecorder is the resolver for the syncFlightRecorder field.
func (r *mutationResolver) SyncFlightRecorder(ctx context.Context, collectSpecID int) (*bool, error) {
	log.Printf("!!! SyncFlightRecorder resolver")
	dbClient := ent.FromContext(ctx)
	colSpec := dbClient.CollectSpec.GetX(ctx, collectSpecID)
	frames, err := colSpec.Frames(ctx)
	if err != nil {
		return nil, err
	}
	var evSpecs []FlightRecorderEventSpecFull
	for _, frameSpec := range frames {
		for _, evSpec := range frameSpec.FlightRecorderEvents {
			var ev FlightRecorderEventSpecFull
			err := json.Unmarshal([]byte(evSpec), &ev)
			if err != nil {
				return nil, err
			}
			evSpecs = append(evSpecs, ev)
		}
	}

	for _, target := range r.getTargets() {
		log.Printf("reconciling breakpoints for process %s - %s", target.processName, target.URL)
		err := reconcileFlightRecorder(ctx, target.URL, evSpecs)
		if err != nil {
			return nil, err
		}
	}
	return nil, nil
}

// CollectionByID is the resolver for the collectionByID field.
func (r *queryResolver) CollectionByID(ctx context.Context, id int) (*ent.Collection, error) {
	log.Printf("!!! querying collection by ID: %d", id)
	dbClient := r.dbClient
	if dbClient == nil {
		panic("!!! nil client")
	}
	return dbClient.Collection.Query().Where(collection.ID(id)).Only(ctx)
}

// GetSnapshot is the resolver for the getSnapshot field.
func (r *queryResolver) GetSnapshot(ctx context.Context, colID int, snapID int, gID *int, filter *string) (*graph.SnapshotInfo, error) {
	log.Printf("!!! GetSnapshot resolver")
	snap, err := r.loadSnapshot(ctx, colID, snapID)
	if err != nil {
		return nil, err
	}
	snap.stacks = filterStacks(snap.stacks, gID, filter)
	agg := snap.stacks.Aggregate(pp.AnyValue)

	gMap := make(map[int]graph.GoroutineInfo, len(snap.stacks.Goroutines))
	for _, g := range snap.stacks.Goroutines {
		frames := make([]graph.FrameInfo, len(g.Stack.Calls))
		for j, c := range g.Stack.Calls {
			frames[j] = graph.FrameInfo{
				Func: c.Func.Complete,
				File: c.RemoteSrcPath,
				Line: c.Line,
			}
		}

		// Flatten all the collected variables, across all the frames.
		var flatVars []graph.CollectedVar
		for _, frames := range snap.framesOfInterest[g.ID] {
			flatVars = append(flatVars, frames.Vars...)
		}
		gMap[g.ID] = graph.GoroutineInfo{
			ID:     g.ID,
			Frames: frames,
			Vars:   flatVars,
		}
	}

	allGs := make([]graph.GoroutineInfo, 0, len(gMap))
	for _, gi := range gMap {
		allGs = append(allGs, gi)
	}

	groups := make([]graph.GoroutinesGroup, len(agg.Buckets))
	for i, b := range agg.Buckets {
		frames := make([]graph.FrameInfo, len(b.Stack.Calls))
		for j, c := range b.Stack.Calls {
			frames[j] = graph.FrameInfo{
				Func: c.Func.Complete,
				File: c.RemoteSrcPath,
				Line: c.Line,
			}
		}
		groups[i] = graph.GoroutinesGroup{
			IDs:    b.IDs,
			Frames: frames,
		}

		for _, gID := range b.IDs {
			if gi, ok := gMap[gID]; ok {
				groups[i].Vars = append(groups[i].Vars, gi.Vars...)
			}
		}
	}

	frDataUntyped := make(map[string]any, len(snap.flightRecorderData))
	for k, v := range snap.flightRecorderData {
		frDataUntyped[k] = v
	}
	si := &graph.SnapshotInfo{
		Raw:                allGs,
		Aggregated:         groups,
		FlightRecorderData: frDataUntyped,
	}
	return si, nil
}

// AvailableVars is the resolver for the availableVars field.
func (r *queryResolver) AvailableVars(ctx context.Context, funcArg string, pcOff int) (*graph.VarsAndTypes, error) {
	agentURL := r.getTargets()[0].URL
	vars, types, err := r.getAvailableVarsFromDelveAgent(agentURL, funcArg, int64(pcOff))
	if err != nil {
		return nil, err
	}
	resVars := make([]graph.VarInfo, len(vars))
	for i, v := range vars {
		resVars[i] = graph.VarInfo{
			Name:             v.Name,
			Type:             v.Type,
			FormalParameter:  v.FormalParameter,
			LoclistAvailable: v.LoclistAvailable,
		}
	}
	resTypes := make([]graph.TypeInfo, len(types))
	for i, t := range types {
		resTypes[i] = graph.TypeInfo{
			Name:            t.Name,
			FieldsNotLoaded: t.FieldsNotLoaded,
		}
		resTypes[i].Fields = make([]graph.FieldInfo, len(t.Fields))
		for j, f := range t.Fields {
			resTypes[i].Fields[j] = graph.FieldInfo{
				Name:     f.Name,
				Type:     f.TypeName,
				Embedded: f.Embedded,
			}
		}
	}

	res := &graph.VarsAndTypes{
		Vars:  resVars,
		Types: resTypes,
	}
	return res, nil
}

// CollectSpec is the resolver for the collectSpec field.
func (r *queryResolver) CollectSpec(ctx context.Context) (*ent.CollectSpec, error) {
	log.Printf("!!! CollectSpec resolver")
	dbClient := r.dbClient
	return dbClient.CollectSpec.Query().Only(ctx)
	//q := r.dbClient.FrameSpec.Query()
	//if funcArg != nil {
	//	q = q.Where(framespec.Frame(*funcArg))
	//}
	//res, err := q.All(ctx)
	//if err != nil {
	//	return nil, err
	//}
	//flat := make([]ent.FrameSpec, len(res))
	//for i := range res {
	//	flat[i] = *res[i]
	//}
	//return flat, nil
}

// TypeInfo is the resolver for the typeInfo field.
func (r *queryResolver) TypeInfo(ctx context.Context, name string) (*graph.TypeInfo, error) {
	agentURL := r.getTargets()[0].URL
	fields, err := r.getTypeInfoFromDelveAgent(agentURL, name)
	if err != nil {
		return nil, err
	}
	return &graph.TypeInfo{
		Name:            name,
		Fields:          fields,
		FieldsNotLoaded: false,
	}, nil
}

// GetTree is the resolver for the getTree field.
func (r *queryResolver) GetTree(ctx context.Context, colID int, snapID int, gID *int, filter *string) (string, error) {
	log.Printf("!!! GetTree resolver")
	snap, err := r.loadSnapshot(ctx, colID, snapID)
	if err != nil {
		return "", err
	}
	stacksSnap := filterStacks(snap.stacks, gID, filter)
	tree := stacks.BuildTree(stacksSnap, snap.framesOfInterest)
	return tree.ToJSON(), nil
}

// FrameSpecsWhere is the resolver for the frameSpecsWhere field.
func (r *queryResolver) FrameSpecsWhere(ctx context.Context, where *ent.FrameSpecWhereInput) ([]ent.FrameSpec, error) {
	dbClient := r.dbClient
	pred, err := where.P()
	if err != nil {
		return nil, err
	}
	rows := dbClient.FrameSpec.Query().Where(pred).AllX(ctx)
	return flatten(rows), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
